% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LDA.R, R/iDA.R
\name{WCS}
\alias{WCS}
\alias{BCS}
\alias{decomposeSVD}
\alias{getSNN}
\alias{getLouvain}
\alias{setFeatureWeights}
\alias{.iDA_core}
\title{Compute each cluster's within class scatter matrix}
\usage{
WCS(splitclusters, diag = FALSE)

BCS(splitclusters)

decomposeSVD(WCSmat, BCSmat, nu = 10)

getSNN(data.use, k.param = 10, prune.SNN = 1/15)

getLouvain(data.use, k.param, prune.SNN)

setFeatureWeights(object, feature.weights)

.iDA_core(
  var.data,
  k.param = 10,
  prune.SNN = 1/15,
  dims.use = 10,
  diag = TRUE,
  c.param = NULL,
  cluster.method = "walktrap"
)
}
\arguments{
\item{splitclusters}{A list of dataframes (from the output of split()) with 
scaled data from each cluster}

\item{diag}{Diagonalize the within class scatter matrix (assume the features
are independent within each cluster)}

\item{WCSmat}{Output from WCS (matrix) of within class scatter}

\item{BCSmat}{Output from BCS (matrix) of between class scatter}

\item{nu}{The number of columns (eigenvectors) to keep}

\item{data.use}{(matrix) Matrix with scaled data to find nearest neighbors}

\item{k.param}{(numeric) Defines k for the k-nearest neighbor algorithm 
(passed to [`getSNN`])}

\item{prune.SNN}{(numeric) Sets the cutoff for acceptable Jaccard index when
computing the neighborhood overlap for the SNN construction. Any edges with
values less than or equal to this will be set to 0 and removed from the SNN
graph. Essentially sets the strigency of pruning (0 --- no pruning, 1 ---
prune everything). Passed to [`getSNN`]}

\item{object}{(SE or SCE) an SE or SCE object in which to fill in feature 
weights}

\item{feature.weights}{(matrix) matrix of features x LDs which is output 
from iDA}

\item{var.data}{(matrix) A matrix of scaled count data for variable genes 
to find embedding for. (sample x variable features)}

\item{dims.use}{(numeric) A vector of the dimensions to use in construction 
of the SNN graph (e.g. To use the first 10 PCs, pass 10) 
(passed to [`getSNN`])}

\item{c.param}{(numeric) Defines the number of desired clusters to be found
in the embedding}

\item{cluster.method}{What clustering method to use}
}
\value{
returns the within class scatter matrix

returns the between class scatter matrix

returns the between class scatter matrix

The SNN graph (igraph object)

a list of identities for clustering

an SE or SCE object with rowData() for the iDA feature weights

n number of dataframes for each cluster's data
}
\description{
Takes in the output from split_clusters() and computes the within class 
scatter matrix

Takes in a list of dataframes with scaled data (output from split()) and 
returns the between class scatter matrix

Takes in within and between cluster covariance matrices (output from WCS
and BSC) and returns the eigenvectors and eigenvalues for the decomp.

Calculate k-nearest neighbors and construct a shared nearest neighbor 
(SNN) graph.

Identify clusters of cells by a shared nearest neighbor (SNN) modularity
optimization based clustering algorithm. Optimize the modularity function to
determine clusters. For a full description of the algorithms, see Waltman and
van Eck (2013) \emph{The European Physical Journal B}.

Takes scaled data and iterates between clustering using the Louvain 
 community detection method and embedding in LDA space, then recluster
 in the LDA transformed data space.
}
