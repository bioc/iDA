---
title: "the iDA package for high-throughput data dimensionality reduction and optimal clustering to determine latent sources of variation"
author: "Theresa Alexander"
date: "`r Sys.Date()`"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Introduction to iDA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# Overview

The iDA package contains functions to create an embedding to reduce the dimensionality of high dimensional data as well as a clustering assignment which optimally separates latent clusters. This method leverages linear discriminant analysis (LDA) in order to find transformations which both separate classes from each other while also minimizing variance within each class. These classes can arise from both known (measured) and unknown (unmeasured) sources.  This embedding can be used as an interpretable reduction to characterize and investigate features which drive class separation or to correct for unwanted sources of variation in downstream analysis.


iDA can take in either a scRNA-seq dataset (as a SingleCellExperiment object) or a bulk-RNAseq dataset (in either a DESeqDataSet or SummarizedExperiment). iDA will check for needed normalization, do a feature selection step, and then perform the iterative LDA. The iDA method is performs the following steps:

******
**Algorithm 1**:  iDA Algorithm

******

![](./iDAalgo.jpg)
# Installation 

```{r, eval = FALSE}
# Install BiocManager if needed
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

# Install iDA
BiocManager::install("iDA")
```

# Libraries

```{r, message=FALSE}
library(iDA)
library(scPipe)
library(celldex)
library(scater)
library(ggplot2)
library(Rtsne)
library(dplyr)
library(gridExtra)
```


# Applying iDA to scRNA-seq data to estimate cell types and top discriminative markers

A common motivation of studies using scRNA-seq is to detect novel cell-types and identify marker genes that define these cell types. The current standard scRNA approach is to use PCA to reduce the computational cost of downstream analyses like unsupervised clustering for putative cell-type identification or non-linear transformations like tSNE or UMAP to visualize global cell-type differences.

Using PCA objective to detect latent discrete structure assumes that latent classes will in fact account for most of the dataset variance. However, since PCA is unsupervised, it does not necessarily separate classes. A more useful approach would be to find an embedding which defines the latent structure of the separation of cell types. iDA uses linear discriminant analysis (LDA) in an iterative approach to maximize the within-to-between cluster variance. The result is 1. vectors for each LD with gene weights which are class-discriminative and 2. a vector of cluster assignments for each cell. We can then evaluate the top weighted genes in each LD to identify putative cell types. 

Since iDA uses a single value decomposition (SVD) of the gene x gene scatter matrices in each iterative step, this method scales relatively well for increasing cell number counts, but not as well for large gene numbers. To help with computational time, we perform a features selection step at the beginning of the method to to limit the size of the scatter matrices. 



This dataset is an experimental dataset in the scPipe software generated by Dr Christine Biben. This experiment profiles gene expression in 383 blood cells for a subset of 1000 genes. The rows names are Ensembl gene ids and the columns are cell names, which is the wall position in the 384 plates.

## QC data 

Since these are raw counts, we will first go through some QC as recommended by OSCA for scRNAseq pre-processing.

```{r}
data("sc_sample_data")
data("sc_sample_qc")
sce <- SingleCellExperiment(assays = list(counts = as.matrix(sc_sample_data)))
organism(sce) <- "mmusculus_gene_ensembl"
gene_id_type(sce) <- "ensembl_gene_id"
QC_metrics(sce) <- sc_sample_qc
demultiplex_info(sce) <- cell_barcode_matching
UMI_dup_info(sce) <- UMI_duplication
sce <- detect_outlier(sce)
sce <- remove_outliers(sce)
```


## iDA decomposition

To run iDA on a SingleCellExperiment object, we simply use the following:

```{r}
start <- Sys.time()
sce <- iDA(sce)
end <- Sys.time()
```

For each iteration, iDA will display a message of the concordance between the previous iteration's clustering and the current iteration's clustering. iDA will stop iterating when concordance is greater than 98%. For this dataset, iDA only iterates one time for a final concordance of 99.7%. 

```{r, echo =FALSE}
message("iDA ran in ", round(end - start, 2), " seconds for the SCE object with ", nrow(colData(sce)), " cells and 1000 variable features.")
```

We can then evaluate the clustering and LDs produced from iDA. The cluster labels are stored as a column `iDAclusters` in the colData() of the SingleCellExperiment object, and the LDs for the cell weights are stored as a reducedDims() under the `iDAcellweights` slot. 


```{r}
#cluster assignments
sce_iDAident <- colData(sce)[["iDAclusters"]]
#iDA cell embedding
sce_iDAembedding <- as.data.frame(reducedDims(sce)[["iDAcellweights"]])
```


There are three clustering methods available to use in the iDA algorithm: louvain community detection, walktrap community detection, or k-means clustering. These can be set in the cluster.method argument:


```{r, eval = FALSE}
sce <- iDA(sce, cluster.method = c("louvain", "walktrap", "kmeans"))
```


You can also change the `nFeatures` parameter to use a different number of HVGs for the embedding. The computation time does increase as nFeatures increases since the embedding is computed with a single value decomposition (SVD) of the gene x gene scatter matrix in each iteration. Because of this though, the computation time scales relatively well for increasing numbers of samples. the `nFeatures` parameter can be from the default number (2000 HVGs) with the following:


```{r, eval = FALSE}
sce <- iDA(sce, nFeatures = 3000)
```


### tSNE of iDA decomposition

Since iDA is still a linear dimensionality reduction method and the dimension will likely be larger than 2 (the dimension will always be k - 1), we may still want to pair this with a non-linear method such as tSNE to visualize the clustering in a 2D plot. We can now treat these LDs just as we would PCs as input to a non-linear dimensionality reduction to reduce this to 2 dimensions for cluster visualization.


```{r}
set.seed(11)
tsne_iDA <- as.data.frame(Rtsne(sce_iDAembedding, pca = FALSE)$Y)

piDA_sce <- ggplot(tsne_iDA, aes(x = V1, y = V2, col = as.factor(sce_iDAident))) + 
  geom_point() + 
  xlab("tSNE 1") +
  ylab("tSNE 2") +
  labs(color = "iDA Cluster") +
  ggtitle("tSNE of the top LDs, colored by iDA Cluster")

piDA_sce
```


## Comparing to PCA decomposition

To compare what information we are gaining from iDA over a PCA reduction, we'll look at the tSNE of the PCA reduction to compare clusters. We will run scater's `calculatePCA()` and then `Rtsne()` on the top 10 PCs.

```{r}
sce_pca <- calculatePCA(sce)
```


```{r}
set.seed(11)
tsne_PCAsce <- as.data.frame(Rtsne(sce_pca[,1:10], pca = FALSE)$Y)

pPCA_sce <- ggplot(tsne_PCAsce, aes(x = V1, y = V2, col = as.factor(sce_iDAident))) + 
  geom_point() + 
  xlab("tSNE 1") +
  ylab("tSNE 2") +
  labs(color = "iDA Cluster") +
  ggtitle("tSNE of the top PCs, colored by iDA Cluster")

pPCA_sce
```


Given this dataset with only highly variable genes, the PCA does a pretty good job of finding the separation between the discrete types, but we note a few key differences. 

First, the two putative cell types in clusters 8 (purple) and 9 (pink) have an ill-defined boundary in the PCA embedding. The iDA embedding offers a much improved within-cluster distance in each cluster and also describes a much better boundary between these two putative cell types. 

Similarly, the separation between clusters 4 (kelly green) and 6 (light blue) is much better defined in the iDA embedding compared to the PCA one. 

Lastly, we also see a much better boundary defined between clusters 1 (salmon) and 2 (orange) in the iDA embedding compared to the PCA one. 

We can evaluate the iDA embedding to see what dimension is defining this cluster split and what genes are highly weighted for this split.



## iDA embedding cell weights

For example, let's evaluate the LD's for which we see separation between cluster 4 and 6. We can evaluate the highly weighted genes for those dimensions to see the expression differences between the clusters. 

```{r}
ggplot(sce_iDAembedding, aes(x = LD7, y = seq(1, nrow(sce_iDAembedding)), color = as.factor(sce_iDAident))) + 
    geom_point()  + 
    labs(colour="iDA Cluster") + 
    xlab( "LD7 Weight") + 
    ylab("Cell Index")
```

We see LD 7 is the dimension which separates clusters 4 (kelly green) and 6 (light blue). We could then investigate the gene weights for LD 7 to identify genes which help in defining this cluster separation. 




# Applying iDA to SummarizedExperiment object

This dataset is from the celldex package and contains normalized expression values for 259 bulk RNA-seq samples generated by Blueprint and ENCODE from pure populations of stroma and immune cells (Martens and Stunnenberg, 2013; The ENCODE Consortium, 2012). The samples were processed and normalized as described in Aran, Looney and Liu et al. (2019).


```{r}
BED <- BlueprintEncodeData(rm.NA = "none",
                           ensembl = FALSE,
                           cell.ont = c("nonna"))
```



## iDA decomposition

iDA can be run on the SummarizedExperiment object. iDA will normalize (if not normalized already), identify highly variable genes (HVGs), and then perform the iterative LDA on the normalized counts of the HVGs as described in the algorithm above We can run iDA with the following:

```{r}
set.seed(11)
start <- Sys.time()
BED <- iDA(BED, cluster.method = "louvain")
end <- Sys.time()
```


```{r, echo = FALSE}
message("This SE dataset with ", nrow(colData(BED)), " samples and 2000 HVGs ran in ", round(end - start, 2), " minutes.")
```


iDA produces both the LD's (linear discriminants) and the cluster assignments. The iDA embedding as well as cluster assignment labels will be added as column data as seen in the colData(). 

```{r}
head(colData(BED))
```

There are three clustering methods available to use in the iDA algorithm: louvain community detection, walktrap community detection, or k-means clustering. These can be set in the cluster.method argument:

```{r, eval = FALSE}
BED <- iDA(BED, cluster.method = c("louvain", "walktrap", "kmeans"))
```


You can also change the `nFeatures` parameter to use a different number of HVGs for the embedding. The computation time does increase as nFeatures increases since the embedding is computed with a single value decomposition (SVD) of the gene x gene scatter matrix in each iteration. Because of this though, the computation time scales relatively well for increasing numbers of samples. the `nFeatures` parameter can be from the default number (2000 HVGs) with the following:

```{r, eval = FALSE}
BED <- iDA(BED, nFeatures = 3000)
```



We can visualize the cluster how many samples were assigned to each cluster.

```{r}
count <- table(colData(BED)[["iDA_clusters"]])
count.df <- data.frame(count)

plot <- ggplot(count.df, aes(x = Var1, y = Freq, fill = Var1))

plot + geom_bar(stat="identity") + 
        labs(title="Cluster Counts",
                     y="Count", x="Cluster") + 
        theme(legend.position="none")
```



When using louvain clustering, iDA identifies 11 clusters, and therefore 10 LD dimensions to best separate these clusters.  

### tSNE of the iDA dimensions

Since iDA is still a linear dimensionality reduction method and the dimension will likely be larger than 2 (the dimension will always be k - 1), we may still want to pair this with a non-linear method such as tSNE to visualize the clustering in a 2D plot. We can now treat these LDs just as we would PCs as input to a non-linear dimensionality reduction to reduce this to 2 dimensions for cluster visualization.


```{r}
set.seed(11)
tsne_ida <- as.data.frame(colData(BED)) %>%
  select(contains("LD")) %>%
  Rtsne(pca = FALSE)

pBED <- tsne_ida$Y %>%
  as.data.frame() %>%
  ggplot(aes(x = V1, y = V2, color = as.factor(as.data.frame(colData(BED))$iDA_clusters))) + 
  geom_point() + 
  xlab("tSNE 1") +
  ylab("tSNE 2") +
  labs(color = "iDA Cluster")

pBED
```

iDA produces an embedding which maximizes the separation between the clusters found. We can then evaluate if these clusters are indicative of known biological variation in the dataset. This bulk RNAseq dataset is comprised of several cell types which were cell sorted and then sequenced to produce homogenous cell type populations to be sequenced together. 


```{r}
pBED_iDA <- tsne_ida$Y %>%
    as.data.frame() %>%
    ggplot(aes(x = V1, y = V2, color = as.data.frame(colData(BED))$label.main)) + 
    geom_point() + 
    xlab("tSNE 1") +
    ylab("tSNE 2") +
    labs(color = "iDA Cluster")

pBED_iDA
```

We see some cell population's expression is much more unique than others. For example, the dendritic cells (DC - pea green) are extremely unique and cluster together around tSNE coordinates (15,3). iDA also captures the expression differences between keratinocytes, monocytes, and Neutrophils. Interestingly, iDA finds trajectory-like differences in the Hematopoietic stem cell (HSC) populations (sea-foam green) around tSNE coordinates (-5, 2.5). These differences could be investigated for potential sequencing batch effects or other sources of variation (cell cycle, cell differentiation, maturity). 


## Comparing to PCA decomposition

We may want to compare the iDA dimensions to what we would get from PCA. Let's compute the PCA dimension reduction for comparison.

```{r}
BED_PCA <- scater::calculatePCA(BED)

set.seed(11)
tsne_pca <- BED_PCA %>%
    Rtsne(pca = FALSE)

pBED_pca <- tsne_pca$Y %>%
    as.data.frame() %>%
    ggplot(aes(x = V1, y = V2, 
            color = colData(BED)[["label.main"]])) + 
    geom_point() + 
    labs(color = "label.main")

pBED_pca
```

We can see generally that the PCA embedding roughly has the same architecture, but the cluster separation and discreteness from the other clusters is not as defined as it is in the iDA projections. Therefore, the top highly weighted genes in each iDA dimension are better indicators of cluster (and therefore cell type) uniqueness. These genes are likely to be candidates which have high fold changes in a differential expression (DE) analysis. 




# What to cite

The iDA package was published in Biostatistics in 2021. The full article can be found here:
https://doi.org/10.1093/biostatistics/kxab030

To cite the iDA package, please include the citation:
Theresa A Alexander, Rafael A Irizarry, Héctor Corrada Bravo, Capturing discrete latent structures: choose LDs over PCs, Biostatistics, 2021;, kxab030, https://doi.org/10.1093/biostatistics/kxab030



```{r}
sessionInfo()
```




